## 1 词向量   
将单词按照含义进行编码成向量的方式称为word embedding。  
### 1.1 word2vec  
它的核心思想是通过词的上下文得到词的向量化表示，有两种方法：CBOW（通过附近词预测中心词）、Skip-gram（通过中心词预测附近的词）。  
![image](https://pic3.zhimg.com/80/v2-c509de0c808367acf62194cd976bc166_720w.webp)  
Word2Vec通过“抽样”模式来解决这种高频词问题。它的基本思想如下：对于我们在训练原始文本中遇到的每一个单词，它们都有一定概率被我们从文本中删掉，而这个被删除的概率与单词的频率有关。词频越高，被删除的概率越大。  
#### 1.1.1 通过附近词预测中心词CBOW   
**CBOW对高频词更友好。从训练角度来看，在更新参数的时候，低频词和高频词一起被更新，它们的更新一方面次数比较少，一方面，每次更新也受到了高频词的影响。**  
通过目标词的上下文的词预测目标词，例如取大小为2的窗口，通过目标词前后两个词预测目标词。常用的窗口大小是5。  
由于CBOW使用的是词袋模型，因此这上下文单词都是平等的，也就是不考虑上下文单词和目标单词之间的距离大小，只要在我们上下文之内即可。  
具体的做法是，设定词向量的维度d，对所有的词随机初始化为一个d维的向量，然后要对上下文所有的词向量编码得到一个隐藏层的向量，通过这个隐藏层的向量预测目标词，CBOW中的做法是简单的相加，然后做一个softmax的分类，例如词汇表中一个有V个不同的词，就是隐藏层d维的向量乘以一个W矩阵（ $R^{d * V}$ ）转化为一个V维的向量，然后做一个softmax的分类。由于V词汇的数量一般是很大的，每次训练都要更新整个W矩阵计算量会很大，同时这是一个样本不均衡的问题，不同的词的出现次数会有很大的差异，**所以论文中采用了两种不同的优化方法多层Softmax和负采样。**  
```python
if (hs) for (d = 0; d < vocab[word].codelen; d++) {
        f = 0;
        l2 = vocab[word].point[d] * layer1_size;
        // Propagate hidden -> output
        for (c = 0; c < layer1_size; c++) f += neu1[c] * syn1[c + l2];
        if (f <= -MAX_EXP) continue;
        else if (f >= MAX_EXP) continue;
        else f = expTable[(int)((f + MAX_EXP) * (EXP_TABLE_SIZE / MAX_EXP / 2))];
        // 'g' is the gradient multiplied by the learning rate
        g = (1 - vocab[word].code[d] - f) * alpha;
        // Propagate errors output -> hidden
        for (c = 0; c < layer1_size; c++) neu1e[c] += g * syn1[c + l2];
        // Learn weights hidden -> output
        // Update weights using the derived error ... but what are these weights??
        for (c = 0; c < layer1_size; c++) syn1[c + l2] += g * neu1[c];
      }
// hidden -> in
      for (a = b; a < window * 2 + 1 - b; a++) if (a != window) {
          c = sentence_position - window + a;
          if (c < 0) continue;
          if (c >= sentence_length) continue;
          last_word = sen[c];
          if (last_word == -1) continue;
          for (c = 0; c < layer1_size; c++) syn0[c + last_word * layer1_size] += neu1e[c];
        }
```  
#### 1.1.2 通过中心词预测附近的词Skip-gram  
**Skip-gram对低频词更友好，但计算量更大。因为每个词在作为中心词时，都要对上下文词预测一次，都要进行2C次的预测、调整，当数据量较少，或者词为生僻词出现次数较少时， 这种多次的调整会使得词向量相对的更加准确。**  
跟CBOW的原理相似，但结构相反，它的输入是目标词，输出是上下文单词，先是将目标词映射为一个隐藏层向量，根据这个向量预测目标词上下文两个词，因为词汇表大和样本不均衡，同样也会采用多层softmax或负采样优化。
```python
for (a = b; a < window * 2 + 1 - b; a++) if (a != window) {
        c = sentence_position - window + a;
        if (c < 0) continue;
        if (c >= sentence_length) continue;
        last_word = sen[c];
        if (last_word == -1) continue;
        l1 = last_word * layer1_size;
        for (c = 0; c < layer1_size; c++) neu1e[c] = 0;
        // HIERARCHICAL SOFTMAX
        if (hs) for (d = 0; d < vocab[word].codelen; d++) {
          f = 0;
          l2 = vocab[word].point[d] * layer1_size;
          // Propagate hidden -> output
          for (c = 0; c < layer1_size; c++) f += syn0[c + l1] * syn1[c + l2];
          if (f <= -MAX_EXP) continue;
          else if (f >= MAX_EXP) continue;
          else f = expTable[(int)((f + MAX_EXP) * (EXP_TABLE_SIZE / MAX_EXP / 2))];
          // 'g' is the gradient multiplied by the learning rate
          g = (1 - vocab[word].code[d] - f) * alpha;
          // Propagate errors output -> hidden
          for (c = 0; c < layer1_size; c++) neu1e[c] += g * syn1[c + l2];
          // Learn weights hidden -> output
          for (c = 0; c < layer1_size; c++) syn1[c + l2] += g * syn0[c + l1];
        }
        for (c = 0; c < layer1_size; c++) syn0[c + l1] += neu1e[c];
```
#### 1.1.3 多层softmax   
通过词频与霍夫曼树建立词汇表，每一个分叉节点即为一个sigmoid，层层递进直到叶子结点，即为多层softmax。Huffman树的叶子节点并不像上面的模型中有一个对应的输出向量，而是所有内部节点具有一个对应的向量。我们要更新的是内部节点的对应向量。

#### 1.1.4 负采样
它是用来提高训练速度并且改善所得到词向量的质量的一种方法。不同于原本每个训练样本更新所有的权重，负采样每次让一个训练样本仅仅更新一小部分的权重，这样就会降低梯度下降过程中的计算量。    
当我们用训练样本 ( input word: "fox"，output word: "quick") 来训练我们的神经网络时，“ fox”和“quick”都是经过one-hot编码的。如果我们的vocabulary大小为10000时，在输出层，我们期望对应“quick”单词的那个神经元结点输出1，其余9999个都应该输出0。在这里，这9999个我们期望输出为0的神经元结点所对应的单词我们称为“negative” word。  
当使用负采样时，我们将随机选择一小部分的negative words（比如选5个negative words）来更新对应的权重。我们也会对我们的“positive” word进行权重更新（在我们上面的例子中，这个单词指的是”quick“）。**对于小规模数据集，选择5-20个比较好，对于大规模数据集则可以仅选择2-5个。**  
效果：假设隐层-输出层拥有300 x 10000的权重矩阵。如果使用了负采样的方法我们仅仅去更新我们的positive word-“quick”的和我们选择的其他5个negative words的结点对应的权重，共计6个输出神经元，相当于每次只更新300×6=1800个权重。对于3百万的权重来说，相当于只计算了0.06%的权重，这样计算效率就大幅度提高。  
